From 857740ffe2eeb5a39bf32569c9ead2a4666ca986 Mon Sep 17 00:00:00 2001
From: Eddie James <eajames@linux.ibm.com>
Date: Thu, 26 Sep 2019 10:33:54 -0500
Subject: [PATCH 1/5] misc: Add MCTP LPC driver for ASPEED KCS devices

Signed-off-by: Andrew Jeffrey <andrew@aj.id.au>
Signed-off-by: Eddie James <eajames@linux.ibm.com>
---
 arch/arm/boot/dts/aspeed-bmc-opp-witherspoon.dts |   8 +
 drivers/misc/Kconfig                             |   7 +
 drivers/misc/Makefile                            |   1 +
 drivers/misc/mctp-lpc.c                          | 351 +++++++++++++++++++++++
 4 files changed, 367 insertions(+)
 create mode 100644 drivers/misc/mctp-lpc.c

diff --git a/arch/arm/boot/dts/aspeed-bmc-opp-witherspoon.dts b/arch/arm/boot/dts/aspeed-bmc-opp-witherspoon.dts
index 47b3580..49e69ac 100644
--- a/arch/arm/boot/dts/aspeed-bmc-opp-witherspoon.dts
+++ b/arch/arm/boot/dts/aspeed-bmc-opp-witherspoon.dts
@@ -291,6 +291,14 @@
 	flash = <&spi1>;
 };
 
+&lpc_host {
+	kcs4: kcs4@0 {
+		compatible = "openbmc,mctp-lpc";
+		interrupts = <8>;
+		status = "okay";
+	};
+};
+
 &mac0 {
 	status = "okay";
 	pinctrl-names = "default";
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index d681b72..d12bf86 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -476,6 +476,13 @@ config XILINX_SDFEC
 
 	  If unsure, say N.
 
+config MCTP_LPC
+	tristate "MCTP LPC binding implementation for ASPEED BMCs"
+	depends on REGMAP
+	help
+	  Implements the MCTP LPC binding via KCS LPC IO cycles for control and
+          LPC FWH cycles for data
+
 config MISC_RTSX
 	tristate
 	default MISC_RTSX_PCI || MISC_RTSX_USB
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index fdd4041..a02debb 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -61,3 +61,4 @@ obj-$(CONFIG_HABANA_AI)		+= habanalabs/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_NPCM7XX_LPC_BPC)	+= npcm7xx-lpc-bpc.o
 obj-$(CONFIG_NPCM7XX_PCI_MBOX)	+= npcm7xx-pci-mbox.o
+obj-$(CONFIG_MCTP_LPC)		+= mctp-lpc.o
diff --git a/drivers/misc/mctp-lpc.c b/drivers/misc/mctp-lpc.c
new file mode 100644
index 0000000..b22ae38
--- /dev/null
+++ b/drivers/misc/mctp-lpc.c
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2019, IBM Corp.
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/regmap.h>
+#include <linux/sched/signal.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+
+#define HOST_ODR             0xca2
+#define HOST_STR             0xca3
+#define HOST_SERIRQ_ID       11
+#define HOST_SERIRQ_TYPE     0
+
+#define LPC_HICRB            0x080
+#define     LPC_HICRB_IBFIF4         BIT(1)
+#define     LPC_HICRB_LPC4E          BIT(0)
+#define LPC_HICRC            0x084
+#define     LPC_KCS4_IRQSEL_MASK     GENMASK(7, 4)
+#define     LPC_KCS4_IRQSEL_SHIFT    4
+#define     LPC_KCS4_IRQTYPE_MASK    GENMASK(3, 2)
+#define     LPC_KCS4_IRQTYPE_SHIFT   2
+#define     LPC_KCS4_OBF4_AUTO_CLR   BIT(1)
+#define     LPC_KCS4_IRQ_HOST	     BIT(0)
+#define LPC_LADR4            0x090
+#define LPC_IDR4             0x094
+#define LPC_ODR4             0x098
+#define LPC_STR4             0x09C
+#define     STR4_IBF	     (1 << 1)
+#define     STR4_OBF	     (1 << 0)
+
+#define RX_BUF_SIZE 1024
+
+struct mctp_lpc {
+	struct miscdevice miscdev;
+	struct regmap *map;
+
+	wait_queue_head_t rx;
+	u8 idr;
+	u8 str;
+};
+
+static irqreturn_t mctp_lpc_irq(int irq, void *data)
+{
+	struct mctp_lpc *priv = data;
+	unsigned long flags;
+	unsigned int idr;
+	unsigned int str;
+
+	spin_lock_irqsave(&priv->rx.lock, flags);
+
+	regmap_read(priv->map, LPC_STR4, &str);
+
+	if (!(str & STR4_IBF)) {
+		spin_unlock_irqrestore(&priv->rx.lock, flags);
+		return IRQ_NONE;
+	}
+
+	/* Have to read IDR to ack IRQ */
+	regmap_read(priv->map, LPC_IDR4, &idr);
+	priv->idr = idr & 0xff;
+	priv->str = str & 0xff;
+
+	wake_up_locked(&priv->rx);
+
+	spin_unlock_irqrestore(&priv->rx.lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static inline struct mctp_lpc *to_mctp_lpc(struct file *filp)
+{
+	return container_of(filp->private_data, struct mctp_lpc, miscdev);
+}
+
+static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
+			     size_t count, loff_t *ppos)
+{
+	struct mctp_lpc *priv = to_mctp_lpc(filp);
+	size_t remaining;
+	ssize_t rc;
+
+	if (!count)
+		return 0;
+
+	if (count > 2 || *ppos > 1)
+		return -EINVAL;
+
+	remaining = count;
+
+	spin_lock_irq(&priv->rx.lock);
+	if (*ppos == 0) {
+		/* YOLO blocking, non-block not supported */
+		rc = wait_event_interruptible_locked(priv->rx, (priv->str & STR4_IBF));
+		if (rc < 0)
+			goto out;
+
+		if (signal_pending(current)) {
+			rc = -EINTR;
+			goto out;
+		}
+
+		if (copy_to_user(buf, &priv->idr, sizeof(priv->idr))) {
+			rc = -EFAULT;
+			goto out;
+		}
+
+		remaining--;
+		buf++;
+	}
+
+	if (remaining) {
+		/* Either:
+		 *
+		 * 1. (count == 1 && *ppos == 1)
+		 * 2. (count == 2 && *ppos == 0)
+		 */
+		unsigned int val;
+		uint8_t str;
+
+		if (priv->str & STR4_IBF) {
+			str = priv->str;
+		} else {
+			regmap_read(priv->map, LPC_STR4, &val);
+			str = val & 0xff;
+		}
+
+		if (copy_to_user(buf, &str, sizeof(str))) {
+			rc = -EFAULT;
+			goto out;
+		}
+
+		remaining--;
+	}
+
+	if (*ppos == 0)
+		priv->str &= ~STR4_IBF;
+
+	WARN_ON(remaining);
+
+	rc = count;
+
+out:
+	spin_unlock_irq(&priv->rx.lock);
+
+	return rc;
+}
+
+static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct mctp_lpc *priv = to_mctp_lpc(filp);
+	uint8_t _data[2], *data = &_data[0];
+	size_t remaining;
+	unsigned int str;
+
+	if (!count)
+		return count;
+
+	if (count > 2)
+		return -EINVAL;
+
+	if (*ppos >= 2)
+		return -EINVAL;
+
+	if (copy_from_user(data, buf, count))
+		return -EFAULT;
+
+	remaining = count;
+
+	if (*ppos == 0) {
+		/* Wait until OBF is clear - we don't get an IRQ */
+		for (;;) {
+			regmap_read(priv->map, LPC_STR4, &str);
+			if (!(str & STR4_OBF)) {
+				regmap_write(priv->map, LPC_ODR4, *data);
+				remaining--;
+				data++;
+				break;
+			}
+
+			if (signal_pending(current))
+				return -EINTR;
+
+			msleep(1);
+		}
+	}
+
+	if (remaining) {
+		spin_lock_irq(&priv->rx.lock);
+		/* Maintain the pretence that IBF is set if necessary */
+		priv->str = *data | (priv->str & STR4_IBF);
+		WARN(!(*data & STR4_OBF), "Clearing OBF with status write\n");
+		regmap_write(priv->map, LPC_STR4, *data);
+		spin_unlock_irq(&priv->rx.lock);
+		remaining--;
+	}
+
+	WARN_ON(remaining);
+
+	regmap_read(priv->map, LPC_STR4, &str);
+	printk("%s:%s:%d: Triggering SerIRQ. STR: 0x%x\n", __FILE__,
+	       __func__, __LINE__, str);
+	/* Trigger Host IRQ */
+	regmap_update_bits(priv->map, LPC_HICRC, LPC_KCS4_IRQ_HOST,
+			   LPC_KCS4_IRQ_HOST);
+
+	return count;
+}
+
+static __poll_t mctp_lpc_poll(struct file *filp, poll_table *wait)
+{
+	struct mctp_lpc *priv = to_mctp_lpc(filp);
+	bool ibf;
+
+	spin_lock_irq(&priv->rx.lock);
+	ibf = priv->str & STR4_IBF;
+	spin_unlock_irq(&priv->rx.lock);
+
+	if (ibf)
+		return EPOLLIN;
+
+	poll_wait(filp, &priv->rx, wait);
+
+	if (signal_pending(current))
+		return -EINTR;
+
+	spin_lock_irq(&priv->rx.lock);
+	ibf = priv->str & STR4_IBF;
+	spin_unlock_irq(&priv->rx.lock);
+
+	return ibf ? EPOLLIN : 0;
+}
+
+static const struct file_operations mctp_lpc_fops = {
+	.owner          = THIS_MODULE,
+	.llseek		= no_seek_end_llseek,
+	.read           = mctp_lpc_read,
+	.write          = mctp_lpc_write,
+	.poll		= mctp_lpc_poll,
+};
+
+static int mctp_lpc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	unsigned int mask, val;
+	struct mctp_lpc *priv;
+	int irq;
+	int rc;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->map = syscon_node_to_regmap(dev->parent->of_node);
+	if (IS_ERR(priv->map)) {
+		dev_err(dev, "Couldn't get regmap\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * Set the LPC address. Simultaneously, test our MMIO regmap works. All
+	 * subsequent accesses are assumed to work
+	 */
+	rc = regmap_write(priv->map, LPC_LADR4, ((HOST_STR) << 16) | HOST_ODR);
+	if (rc < 0)
+		return rc;
+
+	/* Set up the SerIRQ */
+	mask = LPC_KCS4_IRQSEL_MASK
+		| LPC_KCS4_IRQTYPE_MASK
+		| LPC_KCS4_OBF4_AUTO_CLR;
+	val = (HOST_SERIRQ_ID << LPC_KCS4_IRQSEL_SHIFT)
+		| (HOST_SERIRQ_TYPE << LPC_KCS4_IRQTYPE_SHIFT);
+	val &= ~LPC_KCS4_OBF4_AUTO_CLR; /* Unnecessary, just documentation */
+	regmap_update_bits(priv->map, LPC_HICRC, mask, val);
+
+	/* Enable the channel */
+	regmap_update_bits(priv->map, LPC_HICRB,
+			LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E,
+			LPC_HICRB_IBFIF4 | LPC_HICRB_LPC4E);
+
+	/* Trigger waiters from IRQ */
+	init_waitqueue_head(&priv->rx);
+
+	dev_set_drvdata(dev, priv);
+
+	/* Set up the miscdevice */
+	priv->miscdev.minor = MISC_DYNAMIC_MINOR;
+	priv->miscdev.name = "mctp0";
+	priv->miscdev.fops = &mctp_lpc_fops;
+
+	/* Configure the IRQ handler */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	rc = devm_request_irq(dev, irq, mctp_lpc_irq, IRQF_SHARED,
+			      dev_name(dev), priv);
+	if (rc < 0)
+		return rc;
+
+	/* Register the device */
+	rc = misc_register(&priv->miscdev);
+	if (rc) {
+		dev_err(dev, "Unable to register device\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+static int mctp_lpc_remove(struct platform_device *pdev)
+{
+	struct mctp_lpc *ctx = dev_get_drvdata(&pdev->dev);
+
+	misc_deregister(&ctx->miscdev);
+
+	return 0;
+}
+
+static const struct of_device_id mctp_lpc_match[] = {
+	{ .compatible = "openbmc,mctp-lpc" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mctp_lpc_match);
+
+static struct platform_driver mctp_lpc = {
+	.driver = {
+		.name           = "mctp-lpc",
+		.of_match_table = mctp_lpc_match,
+	},
+	.probe  = mctp_lpc_probe,
+	.remove = mctp_lpc_remove,
+};
+module_platform_driver(mctp_lpc);
+
+MODULE_LICENSE("GPL v2+");
+MODULE_AUTHOR("Andrew Jeffery <andrew@aj.id.au>");
+MODULE_DESCRIPTION("OpenBMC MCTP LPC binding on ASPEED KCS");
-- 
1.8.3.1

