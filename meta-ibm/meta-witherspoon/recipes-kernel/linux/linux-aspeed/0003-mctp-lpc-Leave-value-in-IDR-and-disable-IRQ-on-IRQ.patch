From 99684f1b9f8dccb94c29f7f23ae8b4f99b043195 Mon Sep 17 00:00:00 2001
From: Andrew Jeffery <andrew@aj.id.au>
Date: Mon, 13 May 2019 15:58:15 +0930
Subject: [PATCH 3/5] mctp-lpc: Leave value in IDR and disable IRQ on IRQ

Re-enable the IRQ when userspace reads the value out.

Signed-off-by: Andrew Jeffery <andrew@aj.id.au>
---
 drivers/misc/mctp-lpc.c | 187 +++++++++++++++++++++++++++++++-----------------
 1 file changed, 122 insertions(+), 65 deletions(-)

diff --git a/drivers/misc/mctp-lpc.c b/drivers/misc/mctp-lpc.c
index cfa5f99..7346807 100644
--- a/drivers/misc/mctp-lpc.c
+++ b/drivers/misc/mctp-lpc.c
@@ -18,11 +18,6 @@
 #include <linux/uaccess.h>
 #include <linux/wait.h>
 
-#define HOST_ODR             0xca2
-#define HOST_STR             0xca3
-#define HOST_SERIRQ_ID       11
-#define HOST_SERIRQ_TYPE     0
-
 #define LPC_HICRB            0x080
 #define     LPC_HICRB_IBFIF4         BIT(1)
 #define     LPC_HICRB_LPC4E          BIT(0)
@@ -31,6 +26,10 @@
 #define     LPC_KCS4_IRQSEL_SHIFT    4
 #define     LPC_KCS4_IRQTYPE_MASK    GENMASK(3, 2)
 #define     LPC_KCS4_IRQTYPE_SHIFT   2
+#define     LPC_KCS4_IRQTYPE_LOW     0b00
+#define     LPC_KCS4_IRQTYPE_HIGH    0b01
+#define     LPC_KCS4_IRQTYPE_RSVD    0b10
+#define     LPC_KCS4_IRQTYPE_RISING  0b11
 #define     LPC_KCS4_OBF4_AUTO_CLR   BIT(1)
 #define     LPC_KCS4_IRQ_HOST	     BIT(0)
 #define LPC_LADR4            0x090
@@ -40,6 +39,11 @@
 #define     STR4_IBF	     (1 << 1)
 #define     STR4_OBF	     (1 << 0)
 
+#define HOST_ODR             0xca2
+#define HOST_STR             0xca3
+#define HOST_SERIRQ_ID       11
+#define HOST_SERIRQ_TYPE     LPC_KCS4_IRQTYPE_LOW
+
 #define RX_BUF_SIZE 1024
 
 struct mctp_lpc {
@@ -47,40 +51,45 @@ struct mctp_lpc {
 	struct regmap *map;
 
 	wait_queue_head_t rx;
-	u8 idr;
-	u8 str;
+	bool pending;
 };
 
 static irqreturn_t mctp_lpc_irq(int irq, void *data)
 {
 	struct mctp_lpc *priv = data;
 	unsigned long flags;
-	unsigned int idr;
+	unsigned int hicrb;
+	struct device *dev;
 	unsigned int str;
+	irqreturn_t ret;
+
+	dev = priv->miscdev.this_device;
 
 	spin_lock_irqsave(&priv->rx.lock, flags);
 
 	regmap_read(priv->map, LPC_STR4, &str);
-
-	if (!(str & STR4_IBF)) {
-		spin_unlock_irqrestore(&priv->rx.lock, flags);
-		return IRQ_NONE;
+	regmap_read(priv->map, LPC_HICRB, &hicrb);
+
+	if ((str & STR4_IBF) && (hicrb & LPC_HICRB_IBFIF4)) {
+		if (priv->pending)
+			dev_err(dev, "Storm brewing!");
+		dev_dbg(dev, "Received IRQ %d, masking to provide back-pressure\n",
+			irq);
+		/* Mask the IRQ / Enter polling mode */
+		regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_IBFIF4, 0);
+		priv->pending = true;
+		dev_dbg(dev, "Set pending, waking waiters\n");
+		wake_up_locked(&priv->rx);
+		ret = IRQ_HANDLED;
+	} else {
+		dev_dbg(dev, "LPC IRQ triggered, but not for us (str=0x%x, hicrb=0x%x)\n",
+			str, hicrb);
+		ret = IRQ_NONE;
 	}
 
-	if (priv->str & STR4_IBF)
-		dev_err(priv->miscdev.parent,
-			"Buffer overrun: dropping idr=0x%x\n", priv->idr);
-
-	/* Have to read IDR to ack IRQ */
-	regmap_read(priv->map, LPC_IDR4, &idr);
-	priv->idr = idr & 0xff;
-	priv->str = str & 0xff;
-
-	wake_up_locked(&priv->rx);
-
 	spin_unlock_irqrestore(&priv->rx.lock, flags);
 
-	return IRQ_HANDLED;
+	return ret;
 }
 
 static inline struct mctp_lpc *to_mctp_lpc(struct file *filp)
@@ -91,10 +100,14 @@ static inline struct mctp_lpc *to_mctp_lpc(struct file *filp)
 static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 			     size_t count, loff_t *ppos)
 {
-	struct mctp_lpc *priv = to_mctp_lpc(filp);
+	struct mctp_lpc *priv;
+	struct device *dev;
 	size_t remaining;
 	ssize_t rc;
 
+	priv = to_mctp_lpc(filp);
+	dev = priv->miscdev.this_device;
+
 	if (!count)
 		return 0;
 
@@ -105,17 +118,35 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 
 	spin_lock_irq(&priv->rx.lock);
 	if (*ppos == 0) {
+		unsigned int val;
+		u8 str;
+		u8 idr;
+
 		/* YOLO blocking, non-block not supported */
-		rc = wait_event_interruptible_locked(priv->rx, (priv->str & STR4_IBF));
+		dev_dbg(dev, "Waiting for IBF\n");
+		regmap_read(priv->map, LPC_STR4, &val);
+		str = val & 0xff;
+		rc = wait_event_interruptible_locked(priv->rx, (priv->pending || str & STR4_IBF));
 		if (rc < 0)
 			goto out;
 
 		if (signal_pending(current)) {
+			dev_dbg(dev, "Interrupted waiting for IBF\n");
 			rc = -EINTR;
 			goto out;
 		}
 
-		if (copy_to_user(buf, &priv->idr, sizeof(priv->idr))) {
+		dev_dbg(dev, "Woken by IBF IRQ, consuming IDR\n");
+		regmap_read(priv->map, LPC_IDR4, &val);
+		idr = val & 0xff;
+
+		priv->pending = false;
+		/* Re-enable IRQs */
+		dev_dbg(dev, "Consumed IDR, unmasking IRQ\n");
+		regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_IBFIF4,
+				   LPC_HICRB_IBFIF4);
+
+		if (copy_to_user(buf, &idr, sizeof(idr))) {
 			rc = -EFAULT;
 			goto out;
 		}
@@ -131,15 +162,19 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 		 * 2. (count == 2 && *ppos == 0)
 		 */
 		unsigned int val;
-		uint8_t str;
-
-		if (priv->str & STR4_IBF) {
-			str = priv->str;
-		} else {
-			regmap_read(priv->map, LPC_STR4, &val);
-			str = val & 0xff;
-		}
-
+		u8 str;
+
+		regmap_read(priv->map, LPC_STR4, &val);
+		str = val & 0xff;
+		if (*ppos == 0)
+			/*
+			 * If we got this far with `*ppos == 0` then we've read
+			 * data out of IDR, so set IBF when reporting back to
+			 * userspace so userspace knows the IDR value is valid.
+			 */
+			str |= STR4_IBF;
+
+		dev_dbg(dev, "Read status 0x%x\n", str);
 		if (copy_to_user(buf, &str, sizeof(str))) {
 			rc = -EFAULT;
 			goto out;
@@ -148,9 +183,6 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 		remaining--;
 	}
 
-	if (*ppos == 0)
-		priv->str &= ~STR4_IBF;
-
 	WARN_ON(remaining);
 
 	rc = count;
@@ -164,11 +196,15 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
 			      size_t count, loff_t *ppos)
 {
-	struct mctp_lpc *priv = to_mctp_lpc(filp);
 	uint8_t _data[2], *data = &_data[0];
+	struct mctp_lpc *priv;
+	struct device *dev;
 	size_t remaining;
 	unsigned int str;
 
+	priv = to_mctp_lpc(filp);
+	dev = priv->miscdev.this_device;
+
 	if (!count)
 		return count;
 
@@ -178,6 +214,9 @@ static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
 	if (*ppos >= 2)
 		return -EINVAL;
 
+	if (*ppos + count > 2)
+		return -EINVAL;
+
 	if (copy_from_user(data, buf, count))
 		return -EFAULT;
 
@@ -185,37 +224,37 @@ static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
 
 	if (*ppos == 0) {
 		/* Wait until OBF is clear - we don't get an IRQ */
+		dev_dbg(dev, "Waiting for OBF to clear\n");
 		for (;;) {
-			regmap_read(priv->map, LPC_STR4, &str);
-			if (!(str & STR4_OBF)) {
-				regmap_write(priv->map, LPC_ODR4, *data);
-				remaining--;
-				data++;
-				break;
-			}
-
 			if (signal_pending(current))
 				return -EINTR;
 
+			regmap_read(priv->map, LPC_STR4, &str);
+			if (!(str & STR4_OBF))
+				break;
+
 			msleep(1);
 		}
+
+		dev_dbg(dev, "Writing 0x%x to ODR\n", *data);
+		regmap_write(priv->map, LPC_ODR4, *data);
+		remaining--;
+		data++;
 	}
 
 	if (remaining) {
-		spin_lock_irq(&priv->rx.lock);
-		/* Maintain the pretence that IBF is set if necessary */
-		priv->str = *data | (priv->str & STR4_IBF);
-		WARN(!(*data & STR4_OBF), "Clearing OBF with status write\n");
+		if (!(*data & STR4_OBF))
+			dev_err(dev, "Clearing OBF with status write: 0x%x\n",
+				*data);
+		dev_dbg(dev, "Writing status 0x%x\n", *data);
 		regmap_write(priv->map, LPC_STR4, *data);
-		spin_unlock_irq(&priv->rx.lock);
 		remaining--;
 	}
 
 	WARN_ON(remaining);
 
 	regmap_read(priv->map, LPC_STR4, &str);
-	printk("%s:%s:%d: Triggering SerIRQ. STR: 0x%x\n", __FILE__,
-	       __func__, __LINE__, str);
+	dev_dbg(dev, "Triggering SerIRQ (current str=0x%x)\n", str);
 	/* Trigger Host IRQ */
 	regmap_update_bits(priv->map, LPC_HICRC, LPC_KCS4_IRQ_HOST,
 			   LPC_KCS4_IRQ_HOST);
@@ -225,25 +264,43 @@ static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
 
 static __poll_t mctp_lpc_poll(struct file *filp, poll_table *wait)
 {
-	struct mctp_lpc *priv = to_mctp_lpc(filp);
+	struct mctp_lpc *priv;
+	struct device *dev;
+	unsigned int val;
 	bool ibf;
 
+	priv = to_mctp_lpc(filp);
+	dev = priv->miscdev.this_device;
+
+	regmap_read(priv->map, LPC_STR4, &val);
+
 	spin_lock_irq(&priv->rx.lock);
-	ibf = priv->str & STR4_IBF;
-	spin_unlock_irq(&priv->rx.lock);
 
-	if (ibf)
-		return EPOLLIN;
+	ibf = priv->pending || val & STR4_IBF;
 
-	poll_wait(filp, &priv->rx, wait);
+	if (!ibf) {
+		dev_dbg(dev, "Polling on IBF\n");
 
-	if (signal_pending(current))
-		return -EINTR;
+		spin_unlock_irq(&priv->rx.lock);
+
+		poll_wait(filp, &priv->rx, wait);
+		if (signal_pending(current)) {
+			dev_dbg(dev, "Polling IBF was interrupted\n");
+			goto out;
+		}
+
+		regmap_read(priv->map, LPC_STR4, &val);
+
+		spin_lock_irq(&priv->rx.lock);
+
+		ibf = priv->pending || val & STR4_IBF;
+	}
 
-	spin_lock_irq(&priv->rx.lock);
-	ibf = priv->str & STR4_IBF;
 	spin_unlock_irq(&priv->rx.lock);
 
+out:
+	dev_dbg(dev, "Polled IBF state: %s\n", ibf ? "set" : "clear");
+
 	return ibf ? EPOLLIN : 0;
 }
 
-- 
1.8.3.1

